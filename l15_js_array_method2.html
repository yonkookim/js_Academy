<!DOCTYPE html>
<html lang="en" dir="ltr">

<head>
    <meta charset="utf-8">
    <title>js arraymethod2</title>
    <style>
        table, th, td{
            border: 1px solid black;
            padding: 10px;
            text-align: center;
            border-collapse: collapse;
        }
        table{
            width: 500px;
            height: 500px;
        }
        th{
            background-color: rgb(165, 183, 218);
            border-bottom: 2px solid blue;
        }
    </style>
</head>

<body>
    <h1>자바스크립트의 배열 메소드(loop iteration 속성이 있는 method)</h1>
    <p>배열의 메소드 중에서 가장 대표적인 3가지는 모두 반복문의 속성을 가진다.</p>
    <p>반복문 속성이 있는 배열의 메소드(forEach, map, filter)는 배열의 길이만큼 실행되고 사용시
        익명함수를 정의 하게 되는데 이때 정의되는 함수를 콜백함수라 한다.
    <p>콜백함수의 구조 : function(value, index, self){return}</p>
    <p>예) Array.filter(콜백함수) : 콜백함수는 Array의 길이만큼 실행된다.</p>
    </p>

                                    <hr><hr>
    
    <article>
        <h2>forEach(function(value, index, self){}) : forEach는 배열의 길이만큼 콜백함수를 호출하여 반복 실행한다.</h2>
        <p>반복문 for와는 다르게 forEach는 break;로 실행 중간에 멈출 수 없다.</p>
        <p>forEach는 return을 작성해도 역시 중간에 멈출 수 없다.</p>
        <ul>
            <li>["바나나킥","썬칩","빼빼로","오감자"].forEach(function(v.i,s){})
<script>
    const cookies1 = ["바나나킥","썬칩","빼빼로","오감자"];
    cookies1.forEach(function(v,i,s){
        console.log(`v:${v} / i:${i} / s: ${s}`);
    })
    for(let i=0; i<cookies1.length;i++){
        console.log(`cookies1[${i}]: ${cookies1[i]} / i:${i}`);
    }
</script>
            </li>
            <li>Array.forEach(function(value,index,self){})</li>
            <li>Array.forEach(function(value,index{})</li>
            <li>Array.forEach(function(value{}) == for(value of Array){}</li>
            <li>Array.forEach((value,index)=>{})</li>
            <li>Array.forEach(value=>{}) : 매개변수가 하나일때는 괄호도 생략가능, 중괄호 생략은 return을 의미</li>
            <li>nums= [21, 110, -100, 30, 0, 13]로 forEach활용하기
<script>
    const nums= [21, 110, -100, 30, 0, 13];
    let min=Infinity;
    for(let i=0; i<nums.length; i++){
        if(min>nums[i])
            min=nums[i];
    }
    console.log(`min : ${min}`)

    //최대, 최소 foreach 로 한번에 작성하기
    //nums의 합 구하기
    //과제!!!!!!!!!!!!!!! 내림차순정리도 한번 해보라는

    //foreach 로 문자열 value삭제하기

</script>
            </li>
            <li>nums= [21, 110, -100, 30, 0, 13]에서 forEach로 최대,최소 구하기
<script>
    let min2=Infinity;
    let max2=-Infinity;
    nums.forEach(x=>{
        if(min2>x) min2=x;
        if(max2<x) max2=x;
    }
    )
    console.log(`min2 : ${min2} / max2 : ${max2}` )
</script>
            </li>

            
            <li>nums= [21, 110, -100, 30, 0, 13]에서 forEach로 합 구하기
<script>
console.log(typeof "" =="string");
console.log(typeof true =="boolean");
console.log(typeof undefined =="undefined");
console.log(typeof null =="object");
console.log(typeof 0 =="number");
console.log(typeof function(){} =="function");
console.log(typeof [] =="object");
console.log(Array.isArray([]));
console.log(Boolean(Number("십")));
console.log(Boolean(Number("10")));

let sum=0; //아 이걸 처음에 0으로 잡았어야지 -_-;; ""로 잡고나니 문자열의 합으로 만들어져버리지
    nums.forEach(x=>{
        
        sum+=x;
    })
    console.log(sum);
</script>
            </li>


            <li>nums= [21,"십",110,-100,30,0,"10",13]에서 forEach로 문자열 삭제하기
<script>
    const nums2=[21,"십",110,-100,30,0,"10",13];
    nums2.forEach((val,i,self)=>{
    console.log(`val : ${val} / i :${i} / type : ${typeof val}`);
    if(typeof val== "string"){
    self.splice(i,1);   // splice : 배열에서 특정 element삭제하기
        }
        
    })
    console.log(nums2);
</script>
            </li>
        

            <li>nums= [21, 110, -100, 30, 0, 13]에서 forEach로 value들의 제곱들의 배열을 새로 만들기
<script>
    nums2.forEach((value, i, self)=>{
        console.log(Math.abs(value));  //수의 절댓값
        // self[i]= Math.abs(value)*Math.abs(value) // 이렇게 굳이 절댓값으로 바꾸고 계산할 필요는 X
        self[i]= value*value
    });
    console.log(nums2);
</script>
            </li>
        </ul>
    </article>

    <article>
        <h2>map() : 배열의 값을 수정하여 새로운 배열을 반환하는 함수</h2>
        <p>Array.map((value,index,self)=>{return(changeValue)}) : return을 작성하면 해당 인덱스의 value가 바뀐 새 배열이 반환된다.</p>
        <ul>
            <li>
<script>
    nums3= nums2.map(Math.sqrt); //양의제곱근을 반환한 새 배열
    console.log(nums3);
    
    // nums2.map((v,i,s)=>{
    //     console.log(`v: ${v} i: ${i} s: ${s}`); //foreach랑 같은 상황인데?
        // })
   
</script>
            </li>
        </ul>
        <li>
            [-1, -3, -10].map(value=>value*value) :
<script>
    let nums4=[-1, -3, -10];
    let newNums=nums4.map(value=>value*value);
    console.log(nums4);
    console.log(newNums);
    let newNums2=newNums.map(value=>Math.pow(value,3)); //이렇게도 ㅇㅋ
    console.log(newNums2);
</script>
        </li>
    </article>
    
    <article>
        <h2>filter() : 조건에 통과한 배열 요소를 갖는 새 배열을 반환한다.</h2>
        <p>Array.filter(function(v,i,s){return(blooean)})</p>
        <ul>
            <li>[-200, 100, -189, 40, -50, 0, -10, 20, 1].filter 활용법
<script>
    const nums6=[-200, 100, -189, 40, -50, 0, -10, 20, 1];
    //value>0인 값만 가져와 배열 만들기 (다음과 같이 작성하는 방법도 있다. 다만 가독성이 조금 떨어질 수 있다)
    const test=function(v){ return v>-11;}
    console.log(nums6.filter(test));

    console.log(nums6.filter(v=> v>-11));
    nums7=nums6.filter(v=> v<-11);
    console.log(nums7);

    const nums8=[-200, "백", 100, 40, "-40", -50, , -10, "십", 1];
    console.log(nums8.filter(function(v){ //일부러 다른형태로 생략없이도 써봤다.
        return typeof v =="number"
    }));

</script>
        </li>
        <li>
        [-200, 100, -189, 40, -50, 0, -10, 20, 1].filter(v=>typeof v=="number") :
<script>
    const nums9=[-200, "백", 100, 40, "-40", -50, , -10, "십", 1];
    console.log(nums9.filter(v=>typeof v =="number" //위에 본거랑 똑같은데 훨 간단
    ));
</script>
        </li>
        <li>
            [{name:"k", age:10},{name:"a", age:20},{name:"b", age:30},{name:"c", age:40}] 활용
            <br>
<script>
    const persons=[{name:"k", age:10},{name:"a", age:20},{name:"b", age:30},{name:"c", age:40}];
    persons.filter((v,i,)=>{
        console.log(`v : ${v} / i: ${i}`);
        console.log(`JSON.stringify(v) : ${JSON.stringify(v)} / i: ${i}`); //JSON.stringify : JSON의 object를 제대로 출력하게 도와준다.
        console.log(`v.age : ${v.age} / i: ${i}`); // object의 나이(key) 만 출력
    })

    let over20_persons=persons.filter((v,i)=>{
        return v.age>20;
    })
    console.log(over20_persons);
    
    over20_persons.forEach((x)=>{
        document.write(JSON.stringify(x));//JSON.stringify : JSON의 object를  출력하게 도와준다.
    })
</script>
        </li>
    </ul>
</article>

                                    <hr><hr>

    <article>
        <h2>every() : 배열의 모든 요소를 반복적으로 검사하는 함수의 return의 결과값이 모두 true이면 true반환</h2>
        <p>Array.every(function(v,i,s){return boolean}) ==> boolean</p>
        <p>every()는 하나라도 false가 뜨면 콜백함수 호출을 멈추고 false를 반환</p>
        <p>즉 every가 true일때만 true를 반환</p>
        <ul>
            <li>[-200, 100, -189, 400, -50, 0, -10, 20, 1]의 값이 모두 100보다 작은지 검사(with forEach)
<script>
    let arrNum1=[-200, 100, -189, 40, -50, 0, -10, 20, 1];
    let testValue=100;


    let testValueResult=true; //한번이라도 false가 되면 반복문 중단후 결과 출력
    arrNum1.forEach(v=>{
        // console.log(v<testValue);
        if(v>=testValue) testValueResult=false;
        console.log(testValueResult);  
        //두번만 검사하면 바로 false가 되어서 9번의 검사를 채울 필요가 없는데 끝까지 검사하는 모습
        //foreach는 break를 중간에 걸 수가 없는 반복문이며 return 역시 쓰지x 즉 검사에 적절치 않은 함수? 반복문?이다.
    })
    console.log(testValueResult);
    document.write(`/ testValueResult : ${testValueResult}`);
</script>
            </li>
            <li>
                [-200, 100, -189, 400, -50, 0, -10, 20, 1]의 값이 모두 200보다 작은지 검사(with every) : 
<script>
    console.log(testValue);
    let result= arrNum1.every(function(v,i,s){
        return v<testValue;
    });
    document.write(result); //  100때문에 거짓이 뜨지.
</script>
            </li>
        </ul>
    </article>

    <article>
        <h2>some() : 배열의 모든 요소를 반복적으로 검사하는 (콜백)함수의 return의 결과값이 하나라도 true이면 true반환</h2>
        <p>Array.some(function(v,i,s){return boolean}) ==> boolean</p>
        <p>some()는 하나라도 true가 뜨면 콜백함수 호출을 멈추고 true를 반환</p>
        <p>즉 some이 true이면 true 반환(존재 유무의 검사)</p>
        <li>[-200, 100, -189, 400, -50, 0, -10, 20, 1]의 값중 200보다 작은것이 있는지 검사(with foreach, some) : 
<script>
    arrNum1.forEach(v=>{
        if(v>=200) testValueResult=false;  //크거나 같은 것이 있다면 false
    })
    console.log(testValueResult);


    let someResult=arrNum1.some(function(v){return v< -200});
    console.log(someResult);
</script>
        </li>
    </article>

    <article>
        <h2>reduce(r,v)</h2>
        <p>배열의 모든 요소를 실행조건에 맞게 하나의 값을 내어 반환한다. 배열 자체를 바꾸진 않는다.
            <br> 배열의 길이만큼 함수를 호출하는 콜백함수이며 보통 sum을 구할때 편리하다.</p>
            <ul>
            <li>[10,20,30,40,50].reduce((r,v) =>{return r+v , number} , 이때 number는 r의 초기값이며 default=0.</li>
<script>
    const array=[10,20,30,40,50];
    console.log(array.reduce(function(r,v){return r+v , 0;})); //초기값 0 지정(하나마나)
    console.log(array.reduce((r,v)=> r+v));
    console.log(array.reduce((r,v)=> r+v, 100));
    console.log(array.reduce((r,v)=> r+v, -30));
    
    //arr.reduce((r,v)=>r+v , 0) r(result)의 초기값이 0이라고 지정하고 들어가는 함수, 0은 쓰나마나
    //r+a[0]=r
    //r+a[1]=r
    //r+a[2]=r
    //r+a[3]=r .... 의 방식으로 작동
    // 즉 r+=a[i]
</script>

            <li>[10,20,30,40,50].reduce((r,v) =>{return r-v}</li>
<script>
    console.log(array.reduce((r,v)=> r-v));
</script>

            </ul>
    </article>

    <article>
        <h2>reduceRight(r,v)</h2>
        <p>배열의 마지막에서부터 모든 요소를 실행조건에 맞게 하나의 값을 내어 반환한다. 배열 자체를 바꾸진 않는다.
            <br> 배열의 길이만큼 함수를 호출하는 콜백함수이며 보통 sum을 구할때 편리하다.</p>
            <ul>
            <li>[10,20,30,40,50].reduceRight((r,v) =>{return r+v}</li>
<script>
    console.log(array.reduceRight(function(r,v){return r+v;}));
    console.log(array.reduceRight((r,v)=> r+v));
</script>

            <li>[10,20,30,40,50].reduceRight((r,v) =>{return r-v}</li>
<script>
    console.log(array.reduceRight((r,v)=> r-v));
</script>
            </ul>
    </article>


    <article>
        <h2>Array.find((v,i,s)=>booleanTest)</h2>
        <p>배열에서 Test를 통과한 첫번째 요소를 반환(없으면 undefined)</p>
        <ul>
            <li>[1,2,3,4,5,6,7].find(v=> v==4 ) : 
                <script>document.write([1,2,3,4,5,6,7].find(v=> v==4 ))</script>
                <script>document.write([1,2,3,4,5,6,7].find(v=> v>4 ))</script>
                <script>document.write([1,2,3,4,5,6,7].find(v=> v<4 ))</script>
            </li>
            <li>["a","b","c","d","e","f"].find(v=>v=="d") :
                <script>document.write(["a","b","c","d","e","f"].find(v=>v=="d"))</script>
                <script>document.write(["a","b","c","d","e","f"].find(v=>v=="c"))</script>
                <script>document.write(["a","b","c","d","e","f"].find(v=>v=="h"))</script>
            </li>
            
        </ul>
    </article>


    <article>
        <h2>Array.findIndex((v,i,s)=>booleanTest)</h2>
        <p>배열에서 Test를 통과한 첫번째 요소의 index를 반환(없으면 -1 반환)</p>
        <ul>
            <li>[1,2,3,4,5,6,7].findIndex(v=> v==4 ) : 
                <script>document.write([1,2,3,4,5,6,7].findIndex(v=> v==4 ))</script>
                <script>document.write([1,2,3,4,5,6,7].findIndex(v=> v>4 ))</script>
                <script>document.write([1,2,3,4,5,6,7].findIndex(v=> v<4 ))</script>
            </li>
            <li>["a","b","c","d","e","f"].findIndex(v=>v=="d") :
                <script>document.write(["a","b","c","d","e","f"].findIndex(v=>v=="d"))</script>
                <script>document.write(["a","b","c","d","e","f"].findIndex(v=>v=="c"))</script>
                <script>document.write(["a","b","c","d","e","f"].findIndex(v=>v=="h"))</script>
            </li>
            
        </ul>
    </article>


    <article>
        <h2>includes()</h2>
        <p>배열에 해당 요소가 있는지 검사 후 boolean값을 반환</p>
        <ul>
            <li>[1,2,3,4,5,6,7].includes(4) : 
                <script>document.write([1,2,3,4,5,6,7].includes(4))</script></li>
        </ul>
    </article>


    <article>
        <h2>indexOf()</h2>
        <p>배열에 해당 인덱스가 있는지 검사 후 최초놈의 index를 반환</p>
        <>
            <li>[1,2,3,4,4,4,5,6,7].indexOf(4) : 
                <script>document.write([1,2,3,4,4,4,5,6,7].indexOf(4))</script></li>
            <li>["a","b","c","d","e","f"].indexOf("d") :
                <script>document.write(["a","b","c","d","e","f"].indexOf("d"))</script></li>
        </ul>
    </article>


    <article>
        <h2>lastIndexOf()</h2>
        <p>배열에 해당 인덱스가 있는지 검사 후 마지막으로 찾은 녀석의 index를 반환</p>
        <ul>
            <li>[1,2,3,4,4,4,5,6,7].lastIndexOf(v=> v==4 ) : 
                <script>document.write([1,2,3,4,4,4,5,6,7].lastIndexOf(4))</script></li>
        </ul>
    </article>


    <article>
        <h2>keys()</h2> <!-- 이부분 개인적 공부 필요하겠는데 자다 일어나서 그런가 뭔말인지 하나도..-->
        <p>keys()를 호출하면 반복과 관련된 객체인 iterator가 반환되고 iterator에서 key(index)를 확인할 수 있다.</p>
        <p>Iterator.next()=>[반환되는 데이터, 반환할 데이터가 있는지] / for of에서 사용 for(반환되는 데이터 of Iterator.next())</p>
        <p>[10,20,30,40].keys() : <script>document.write([10,20,30,40].keys())</script></p>
        <p>[10,20,30,40].keys() for of 출력:
            <script>
                const arr2=[10,20,30,40]
                let keys=[10,20,30,40].keys()
                console.log(keys); //Array Iterator 가 반환되는데 이건 뭐지 이것이 배열에선 인덱스??
                for(key of keys){
                    document.write(`key: ${key},`)
                }
            </script>
        </p>
        <p>object.keys([10,20,30,40]) : <script>document.write(Object.keys([10,20,30,40]))</script></p>
    </article>


    <article>
        <h2>Array.isArray()</h2>
        <p>typeof Array : object를 반환한다. 이때 데이터가 배열인지 확인하는 함수</p>
        <p>배열은 기본데이터 타입이 없기 때문에 리터럴한 입력(new 선언 안하는 것)을 사용해도 인스턴스 객체이다.</p>
        <p>let a=10;(리터럴한 표현) // let a=new Number(10),  const b=[1,2,3] // const b= new Array(1,2,3) </p>
        <ul>
            <li>typeof [1,2,3,4] : <script>document.write(typeof [1,2,3,4])</script></li>
            <li>Array.isArray([1,2,3,4]) : <script>document.write(Array.isArray([1,2,3,4]))</script></li>
            <li>Array.isArray( new Array(1,2,3,4)) : <script>document.write(Array.isArray( new Array(1,2,3,4)))</script></li>

            <br><br>

            <li>객체 instanceof 타입 : 객체의 타입을 비교, 이때 타입은 부모타입도 포함</li>
            <p>기본데이터 타입은 이런 비교검사가 불가(대신 typeof를 쓸수 있지), 배열은 어떻게 적어도 기본데이터가 아니니 늘 검사 가능</p>
            <li>[1,2,3] instanceof Array : <script>document.write([1,2,3] instanceof Array)</script></li>
            <li>[1,2,3] instanceof object : <script>document.write([1,2,3] instanceof Object)</script></li>
            <li>new Array(1,2,3) instanceof object : <script>document.write(new Array(1,2,3) instanceof Object)</script></li>
            <li>"안녕" instanceof String : <script>document.write("안녕" instanceof String)</script></li>
            <!-- "안녕" 과 같은 기본데이터 타입은 비교검사하지 못한다.-->
            <li>new String("안녕") instanceof String : <script>document.write(new String("안녕") instanceof String)</script></li>
            <li>new String("안녕") instanceof Object : <script>document.write(new String("안녕") instanceof Object)</script></li>
        </ul>
    </article>


        <article>
            <h2>문제</h2>
            <ul>
                <li>총 점수를 구하세요. <input type="button" value="총점"> </li>
                <li>평균 점수를 구하세요. <input type="button" value="평균"> </li>
                <li>최소 점수를 구하세요. <input type="button" value="최소"> </li>
                <li>최대 점수를 구하세요. <input type="button" value="최대"> </li>
                <li>낙제(50) 존재 여부를 찾으세요 <input type="button" value="낙제"> </li>
                <li>만점 존재 여부를 찾으세요 <input type="button" value="만점"> </li>
                <li>모든 점수를 100점 만점에서 4.5점 만점으로 변경하세요<button type="button" name="button">4.5점 만점</button></li>
        <li>
            <form name="someTestForm" action="index.html" method="post" >
                <p><label>수학점수: <input type="number" class="score" name="m" value="70"></label></p>
                <p><label>영어점수: <input type="number" class="score" name="e" value="90"></label> </p>
                <p><label>화학점수: <input type="number" class="score" name="c" value="100"></label></p>
                <p><label>국사점수: <input type="number" class="score" name="h" value="30"></label></p>
                <p><label>국어점수: <input type="number" class="score" name="k" value="70"></label></p>
                <p><label>총 점수: <input type="number" name="total" value="0"></label></p>
                <p><label>평균점수: <input type="number" name="average" value="0"></label></p>
                <p><label>최소점수: <input type="number" name="min" value="0"></label></p>
                <p><label>최대점수: <input type="number" name="max" value="0"></label></p>
                <p><label>낙제(50)여부 : <input type="number" name="is_f" value="0"></label></p>
                <p><label>만점여부: <input type="number" name="is_ten" value="0"></label></p>
            </form>
<script>
    const someTestForm1=document.forms.someTestForm
    // const someTestForm1=document.forms["someTestForm"] //똑같은 명령어
    console.log(someTestForm1.querySelectorAll("[type=number].score"));  // 이 문법 숙지~~~~~~~~~~~~~~!!!!
    //"[type=number].score" : type=number인데 그중 클래스가 score인 얘들 다 불러와~! 경로는 다 "string"취급이구나...
    const arrScores2=someTestForm1.querySelectorAll("[type=number].score");

    const arrScores22=Array.from(arrScores2); 
    // arrScores2(domList)로부터 array를 만들어내는 함수 Array.from() --> 이제 foreach 말고 every, some 등도 사용 가능



    const abcdef=someTestForm1.querySelectorAll(".score"); //근데 애초 클래스 이용할거면 이게 더 간단하지
    console.log(abcdef);

    const arrScores3=Number(arrScores2.value); //나의 시도.......근데
    console.log(arrScores3); //이건 왜 NaN으로 뜰까?


    // console.log(Number("100")); 

    let sum2=0;
    arrScores2.forEach((v,i)=>{
        // console.log(v);
        let numV = Number(v.value);
        // console.log(numV);
       sum2+=numV;
    })

    document.write(`총점 : ${sum2}//`);

    document.write(`평균: ${sum2/5}//`);

    let min3=Infinity;
    arrScores2.forEach((v,i)=>{
        if(min3>Number(v.value)){
            min3=Number(v.value);
        }
    })
    // console.log(min3);
    document.write(`최저점: ${min3}//`);
    



    let max3=-Infinity;
    arrScores2.forEach((v,i)=>{
        if(max3<Number(v.value)){
            max3=Number(v.value);
        }
    })
    // console.log(max3);
    document.write(`최고점: ${max3}//`);




    let result2=true; // 뒤늦게 알려준 배열로 바꿔주는 거 적용 안하고.. 포이츠로 했다....
    arrScores2.forEach(v=>{
        if(Number(v.value)<50) result2=false;
        // console.log(result2);  
    })
    document.write(`낙제가 존재하면 false -> ${result2}//`);


    // <<위에서 판정한 낙제유무를 some을 활용하여 다시 판정 >>
    let result22=arrScores22.some(function(v){
        // console.log(Number(v.value))
        return Number(v.value)<50        //여기선 Number 안쓰고도 크기비교를 제대로 해내는데 위와 다른 이유가뭐지
         }
    );
    console.log(result22);





    let result3=false; 
    arrScores2.forEach(v=>{
        if(Number(v.value)==100) result3=true;
        console.log(result3);  
    })
    document.write(`만점이 존재하면 true -> ${result3}//`);
    
// <<위에서 판정한 만점유무를 some을 활용하여 다시 판정 >>
    let result33=arrScores22.some(function(v){return v.value=100});
    console.log(result33);




    let changeScores=[];   //이건 기존의 점수가 아닌 만점이 바뀐 새 배열을 가져 온 것.
    
    arrScores2.forEach((v,i)=>{
        changeScores[i]=Number(v.value)*(0.045);
        console.log(changeScores);
    });
    console.log(changeScores);
    document.write(`만점을 4.5점으로 바꿔서 점수 출력 : ${changeScores}`);

    // arrScores2.forEach((v,i)=>{  //기존의 점수가 바뀌도록 제대로 작동시켰다.
    //     v.value=Number(v.value)*(0.045);
    // });
    // console.log(arrScores2);
    // document.write(`만점을 4.5점으로 바꿔서 점수 출력 : ${arrScores2.value}`);





</script>


         </li>
        <li>
            <table id="scoreTable">
                <tr>
                    <th>과목</th>
                    <th>점수(100만점)</th>
                    <th>점수(4.5만점)</th>
                    <th>낙제</th>
                    <th>만점</th>
                    <th>성적(ABC)</th>
                </tr>
                <tr>
                    <td>수학</td>
                    <td class="score1" ></td>
                    <td class="score2"></td>
                    <td class="fail"></td>
                    <td class="perfect"></td>
                    <td class="abc"></td>
                </tr>
                <tr>
                    <td>영어</td>
                    <td class="score1"></td>
                    <td class="score2"></td>
                    <td class="fail"></td>
                    <td class="perfect"></td>
                    <td class="abc"></td>
                </tr>
                <tr>
                    <td>화학</td>
                    <td class="score1"></td>
                    <td class="score2"></td>
                    <td class="fail"></td>
                    <td class="perfect"></td>
                    <td class="abc"></td>
                </tr>
                <tr>
                    <td>국사</td>
                    <td class="score1"></td>
                    <td class="score2"></td>
                    <td class="fail"></td>
                    <td class="perfect"></td>
                    <td class="abc"></td>
                </tr>
                <tr>
                    <td>국어</td>
                    <td class="score1"></td>
                    <td class="score2"></td>
                    <td class="fail"></td>
                    <td class="perfect"></td>
                    <td class="abc"></td>
                </tr>
                <tr>
                    <td>총점</td>
                    <td class="sum1"></td>
                    <td>평균(100)</td>
                    <td class="average1"></td>
                    <td>평균(4.5)</td>
                    <td class="average2"></td>
                </tr>
            </table>
        </li>

<script>
    //작업도중 갑자기 수학점수가 70점에서 100점이 되었는데 대체 어느과정부터 변한거지...???
    //테이블 안에 만점 표기하면서부터인것 같은데;;;
    let tableScores=[];
    arrScores2.forEach((v,i)=>{
        tableScores[i]=Number(v.value);
    })
    console.log(tableScores);


    const arrScore111 = document.querySelectorAll('.score1');
    console.log(arrScore111);
    
    const arrScore222 = document.querySelectorAll('.score2');
    console.log(arrScore222);

    const arrFails = document.querySelectorAll('.fail');
    console.log(arrFails);

    const arrPerfects = document.querySelectorAll('.perfect');
    console.log(arrPerfects);

    const arrAbc = document.querySelectorAll('.abc');

    arrScore111.forEach((v,i)=>{
        // console.log(tableScores[i]);
        // console.log(v);
        v.innerText = tableScores[i];
    })

    arrScore222.forEach((v,i)=>{
        v.innerText = changeScores[i];
    })

    arrScore111.forEach((v,i,s)=>{
        if(s[i].innerText<50){
            arrFails[i].innerText="낙제";
        } 
    })

    arrScore111.forEach((v,i,s)=>{
        if(s[i].innerText==100){
            arrPerfects[i].innerText="만점";
        } 
    })

    let sumScore=0;
    tableScores.forEach((v,i)=>{
        sumScore+=v;
    })
    console.log(sumScore);
    
    document.querySelector('.sum1').innerText=sumScore;

    let average100=sumScore/5;
    console.log(average100);
    
    document.querySelector('.average1').innerText=average100;

    let sumChange=0;
    changeScores.forEach((v,i)=>{
        sumChange+=v;
    })
    console.log(sumChange);
    
    let averageChange=sumChange/5;
    console.log(averageChange);

    document.querySelector('.average2').innerText=averageChange;

    changeScores.forEach((v,i,s)=>{
        if(s[i]==4.5) arrAbc[i].innerText = "A+";
        else if(s[i]>=4) arrAbc[i].innerText = "A";
        else if(s[i]>=3.5) arrAbc[i].innerText = "B+";
        else if(s[i]>=3.0) arrAbc[i].innerText = "B";
        else if(s[i]>=2.5) arrAbc[i].innerText = "C+";
        else if(s[i]>=2.0) arrAbc[i].innerText = "C";
        else{ arrAbc[i].innerText = "F";}
        
    })
</script>
     </ul>

        
        </article>
    
</body>
</html>